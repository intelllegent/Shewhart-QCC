output$distPlot <- renderPlot({
# Take a dependency on input$goButton. This will run once initially,
# because the value changes from NULL to 0.
input$goButton
# Use isolate() to avoid dependency on input$obs
dist <- isolate(rnorm(input$obs))
hist(dist)
})
}
shinyApp(ui, server)
}
if (interactive()) {
# Display an important message that can be dismissed only by clicking the
# dismiss button.
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog")
),
server = function(input, output) {
observeEvent(input$show, {
showModal(modalDialog(
title = "Important message",
"This is an important message!"
))
})
}
)
# Display a message that can be dismissed by clicking outside the modal dialog,
# or by pressing Esc.
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog")
),
server = function(input, output) {
observeEvent(input$show, {
showModal(modalDialog(
title = "Somewhat important message",
"This is a somewhat important message.",
easyClose = TRUE,
footer = NULL
))
})
}
)
# Display a modal that requires valid input before continuing.
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog"),
verbatimTextOutput("dataInfo")
),
server = function(input, output) {
# reactiveValues object for storing current data set.
vals <- reactiveValues(data = NULL)
# Return the UI for a modal dialog with data selection input. If 'failed' is
# TRUE, then display a message that the previous value was invalid.
dataModal <- function(failed = FALSE) {
modalDialog(
textInput("dataset", "Choose data set",
placeholder = 'Try "mtcars" or "abc"'
),
span('(Try the name of a valid data object like "mtcars", ',
'then a name of a non-existent object like "abc")'),
if (failed)
div(tags$b("Invalid name of data object", style = "color: red;")),
footer = tagList(
modalButton("Cancel"),
actionButton("ok", "OK")
)
)
}
# Show modal when button is clicked.
observeEvent(input$show, {
showModal(dataModal())
})
# When OK button is pressed, attempt to load the data set. If successful,
# remove the modal. If not show another modal, but this time with a failure
# message.
observeEvent(input$ok, {
# Check that data object exists and is data frame.
if (!is.null(input$dataset) && nzchar(input$dataset) &&
exists(input$dataset) && is.data.frame(get(input$dataset))) {
vals$data <- get(input$dataset)
removeModal()
} else {
showModal(dataModal(failed = TRUE))
}
})
# Display information about selected data
output$dataInfo <- renderPrint({
if (is.null(vals$data))
"No data selected"
else
summary(vals$data)
})
}
)
}
if (interactive()) {
ui <- fluidPage(
textInput("caption", "Caption", "Data Summary"),
verbatimTextOutput("value")
)
server <- function(input, output) {
output$value <- renderText({ input$caption })
}
shinyApp(ui, server)
}
runApp()
runApp()
runApp()
## Only run this example in interactive R sessions
if (interactive()) {
## App 1: Sample usage
shinyApp(
ui = fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
),
server = function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(input$button, {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
)
## App 2: Using `once`
shinyApp(
ui = basicPage( actionButton("go", "Go")),
server = function(input, output, session) {
observeEvent(input$go, {
print(paste("This will only be printed once; all",
"subsequent button clicks won't do anything"))
}, once = TRUE)
}
)
## App 3: Using `ignoreInit` and `once`
shinyApp(
ui = basicPage(actionButton("go", "Go")),
server = function(input, output, session) {
observeEvent(input$go, {
insertUI("#go", "afterEnd",
actionButton("dynamic", "click to remove"))
# set up an observer that depends on the dynamic
# input, so that it doesn't run when the input is
# created, and only runs once after that (since
# the side effect is remove the input from the DOM)
observeEvent(input$dynamic, {
removeUI("#dynamic")
}, ignoreInit = TRUE, once = TRUE)
})
}
)
}
shinyApp(
ui = basicPage( actionButton("go", "Go")),
server = function(input, output, session) {
observeEvent(input$go, {
print(paste("This will only be printed once; all",
"subsequent button clicks won't do anything"))
}, once = TRUE)
}
)
if (interactive()) {
## App 1: Sample usage
shinyApp(
ui = fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
),
server = function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(input$button, {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
)}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("shinyjs")
library(shinyjs)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
if (interactive()) {
library(shiny)
shinyApp(
ui = fluidPage(
useShinyjs(),  # Set up shinyjs
actionButton("btn", "Click me"),
textInput("element", "Watch what happens to me")
),
server = function(input, output) {
observeEvent(input$btn, {
# Change the following line for more examples
toggleState("element")
})
}
)
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
p1 <- plot_ly(economics, x = ~date, y = ~uempmed)
p2 <- plot_ly(economics, x = ~date, y = ~unemploy)
subplot(p1, p2, p1, p2, nrows = 2, margin = 0.05)
economics_long %>%
split(.$variable) %>%
lapply(function(d) plot_ly(d, x = ~date, y = ~value)) %>%
subplot(nrows = NROW(.), shareX = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
for (k in 1:2){print(k)}
runApp()
runApp()
create_plot <- function(tabl, text){
p <- plot_ly(
name = "Your Sequence",
data = tabl,
type = 'scatter',
mode = 'lines+markers',
text = text,
hoverinfo  = 'text+name',
x = ~point,
y = ~value
)
p <- layout(p=p,
title = 'Value distribution',
legend = list(orientation = 'h'),
xaxis = list(
type = 'category'
)
)
return(p)
}
read_seq <- read_excel("input$file1$datapat", sheet = 1, col_names = TRUE, col_types = col_type)
num_seq <<- as.vector(unlist(unclass(read_seq[1])))
data_seq <<- tibble(point = 1:length(num_seq), value = num_seq)
point_info <<- paste("Point: ", data_seq$point, "<br>", "Value: ",
data_seq$value)
read_seq <- read_excel("Test.xlsx", sheet = 1, col_names = TRUE, col_types = col_type)
num_seq <<- as.vector(unlist(unclass(read_seq[1])))
data_seq <<- tibble(point = 1:length(num_seq), value = num_seq)
point_info <<- paste("Point: ", data_seq$point, "<br>", "Value: ",
data_seq$value)
read_seq <- read_excel("Test.xlsx", sheet = 1, col_names = TRUE, col_types = c("skip", "guess", "skip"))
num_seq <<- as.vector(unlist(unclass(read_seq[1])))
data_seq <<- tibble(point = 1:length(num_seq), value = num_seq)
point_info <<- paste("Point: ", data_seq$point, "<br>", "Value: ",
data_seq$value)
read_seq
data_seq
create_plot(tabl = data_seq, text = point_info)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
c("a",5)
c(c("a",5))
c(paste("a",5))
list[1] <- 1
list(5)
list(
xref = 'paper',
yref = 'y',
x = 0.05,
y = line_value[i],
xanchor = 'left',
yanchor = 'bottom',
text = ~paste("<b>", line_name[i], round(line_value[i]), "   Sigm: ", round(Sigm, 5),"</b>"),
font = list(family = 'sans-serif',
size = 14),
showarrow = FALSE)
list(
xref = 'paper',
yref = 'y',
x = 0.05,
y = line_value[i],
xanchor = 'left',
yanchor = 'bottom',
font = list(family = 'sans-serif',
size = 14),
showarrow = FALSE)
list(
xref = 'paper',
yref = 'y',
x = 0.05,
xanchor = 'left',
yanchor = 'bottom',
font = list(family = 'sans-serif',
size = 14),
showarrow = FALSE)
runApp()
runApp()
ine_value <- c(average - 3 * sigma, average, average + 3 * sigma)
average=10
sigma=2
line_value <- c(average - 3 * sigma, average, average + 3 * sigma)
line_value
annot <- c(paste("LCL: ", round(line_value[1], 4)),
paste("Aver: ", round(line_value[2], 4), "   Sigm: ", round(sigma, 4)),
paste("UCL: ", round(line_value[3], 4))
)
annot
annot[1]
annot[2]
annot[3]
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(xaxis_val)
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
read_excel(datapath, sheet = 1, col_names = TRUE)
read_excel("Test.xlsx", sheet = 1, col_names = TRUE)
a <- read_excel("Test.xlsx", sheet = 1, col_names = TRUE)
a
a[1]
as.character(a[1])
str(as.character(a[1]))
class(as.character(a[1]))
is.list(as.character(a[1]))
runApp()
runApp()
as.character(a[1])
as.character(a[1])[1]
as.character(a[1])[2]
a[1]
b <- paste(a[1])
b
a[[1]]
is.vector(a[[1]])
str(a[[1]])
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
devtools::install(ShewhartQCC)
devtools::install("ShewhartQCC")
Shewchart_1(1,1,1,1)
library(ShewhartQCC)
Shewchart_1(1,1,1,1)
Shewchart_1(1,1,1,3)
View(Shewchart_1)
View(Shewchart_1)
View(Shewchart_2)
View(Shewchart_3)
View(Shewchart_4)
View(Shewchart_5)
View(Shewchart_6)
View(Shewchart_7)
View(Shewchart_8)
shiny::runApp()
traceback()
Shewchart_1(data_seq, data_seq$value, Aver_plt + 3*Sigm_plt,  Aver_plt + 3*Sigm_plt)
Shewchart_2(data_seq, data_seq$value, Aver_plt, Sigm_plt)
Shewchart_3(data_seq, data_seq$value)
Shewchart_4(data_seq, data_seq$value)
Shewchart_5(data_seq, data_seq$value, Aver_plt, Sigm_plt)
Shewchart_6(data_seq, data_seq$value, Aver_plt, Sigm_plt)
Shewchart_7(data_seq, data_seq$value, Aver_plt, Sigm_plt)
Shewchart_8(data_seq, data_seq$value, Aver_plt, Sigm_plt)
View(Shewchart_5)
View(Shewchart_5)
hewchart_5(data_seq, data_seq$value, Aver_plt, Sigm_plt)
Shewchart_5(data_seq, data_seq$value, Aver_plt, Sigm_plt)
traceback()
View(Shewchart_5)
traceback()
Shewchart_5(data_seq, data_seq$value, Aver_plt, Sigm_plt)
devtools::install("ShewhartQCC")
library(ShewhartQCC)
Shewchart_5(data_seq, data_seq$value, Aver_plt, Sigm_plt)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
View(a)
runApp()
runApp()
runApp()
View(a)
View(a)
View(a)
traceback()
runApp()
runApp()
View(trash_1)
View(trash_2)
View(trash_3)
View(trash_2)
View(trash_3)
runApp()
View(trash_1)
View(trash_2)
View(trash_3)
View(Shewchart_1)
trash_1 <<- Shewchart_1(data_seq, data_seq$value, Aver_plt + Sigm_plt,  Aver_plt + Sigm_plt)
Shewchart_1(data_seq, data_seq$value, Aver_plt + Sigm_plt,  Aver_plt + Sigm_plt)
ttt <- tibble(data = c("ddd","aaa","ttt","aaa"), value = c(10,15,20,25))
View(Shewchart_1)
Shewchart_1(ttt, ttt$value, 21,  17)
Shewchart_1(ttt, ttt$value, 9, 26)
trash_1 <<- Shewchart_1(data_seq, data_seq$value, Aver_plt + 3*Sigm_plt,  Aver_plt -3*Sigm_plt)
trash_1
shiny::runApp()
shiny::runApp()
View(trash_1)
View(trash_2)
shiny::runApp()
runApp()
View(trash_2)
